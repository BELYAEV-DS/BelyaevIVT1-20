def det2(matrix):
    """Функция нахождения определителя 2х2 по определению"""

    for_ret = matrix[0][0] * matrix[1][1] - matrix[1][0] * matrix[0][1]
    return for_ret

# for_sum необходим для складывания по формуле
# https://math1.ru/education/matrix/detr.html
# это aij*Aij
# last необходима для сохранения алгебраического дополнения, с которым работаем
# last = 1, потому что в начале у нас чистая матрица, и не каких алгебраических дополнений пока нет


def det(matrix, for_sum=None, last=1):
    """Рекурсивная функция нахождения определителя"""

    # Необходимо проверить for_sum для того, чтобы определить, работаем мы с новой или старой матрицей
    if for_sum is None:
        for_sum = list()    # реализовываем список, который будем складывать по определению

    # Теперь необходимо проверить размерности матрицы, для определения методы вычисления определителя
    if len(matrix) == 1:
        for_sum.append(matrix[0][0])    # реализуем так, потому что это может быть одним из миноров
    if len(matrix) == 2:
        for_sum.append(det2(matrix)*last)   # дошли до 2x2 матрицы, считаем по определению, не факт, что это конкретно
        # матрица 2x2 заданная в начале, это может быть один из алгебраических дополнений, поэтому необходимо
        # указать предшествующий множитель
    if len(matrix) > 2:    # размерность 3 и более
        # Будем понижать порядок разложением по 1-ой строке
        for i, element in enumerate(matrix[0]): # enumerate возвращает координату элемента и значение (кортеж)
            # Здесь идут преобразования для понижения порядка
            t_matrix = [list(x) for x in zip(*matrix[1:])]
            del t_matrix[i]    # удаление i-ого элемента, нам же необходимо удалять строки и столбцы
            # Сам минор, при подсчете алгебраического дополнения он используется
            minor = [list(x) for x in zip(*t_matrix)]
            # В миноре нам тоже нужен определитель, придется считать, опять рукурсия
            for_sum = det(minor, for_sum, last * matrix[0][i] * (-1) ** (i + 2))    # определяется множитель по формуле
    return for_sum    # итоговая сумма по формуле


def determinant(matrix):
    # Функция подсчета определителя, вызываем ее
    return sum(det(matrix))

